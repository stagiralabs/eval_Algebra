import VerifiedAgora.tagger
/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/

import Mathlib.Algebra.Homology.Embedding.Extend
import Mathlib.Algebra.Homology.Embedding.IsSupported
import Mathlib.Algebra.Homology.Embedding.Restriction

/-!
# The stupid truncation of homological complexes

Given an embedding `e : c.Embedding c'` of complex shapes, we define
a functor `stupidTruncFunctor : HomologicalComplex C c' ‚•§ HomologicalComplex C c'`
which sends `K` to `K.stupidTrunc e` which is defined as `(K.restriction e).extend e`.

## TODO (@joelriou)
* define the inclusion `e.stupidTruncFunctor C ‚ü∂ ùü≠ _` when `[e.IsTruncGE]`;
* define the projection `ùü≠ _ ‚ü∂ e.stupidTruncFunctor C` when `[e.IsTruncLE]`.

-/

open CategoryTheory Category Limits ZeroObject

variable {Œπ Œπ' : Type*} {c : ComplexShape Œπ} {c' : ComplexShape Œπ'}

namespace HomologicalComplex

variable {C : Type*} [Category C] [HasZeroMorphisms C] [HasZeroObject C]

variable (K L M : HomologicalComplex C c') (œÜ : K ‚ü∂ L) (œÜ' : L ‚ü∂ M)
  (e : c.Embedding c') [e.IsRelIff]

/-- The stupid truncation of a complex `K : HomologicalComplex C c'` relatively to
an embedding `e : c.Embedding c'` of complex shapes. -/
noncomputable def stupidTrunc : HomologicalComplex C c' := ((K.restriction e).extend e)

instance : IsStrictlySupported (K.stupidTrunc e) e := by
  dsimp [stupidTrunc]
  infer_instance

/-- The isomorphism `(K.stupidTrunc e).X i' ‚âÖ K.X i'` when `i` is in the image of `e.f`. -/
noncomputable def stupidTruncXIso {i : Œπ} {i' : Œπ'} (hi' : e.f i = i') :
    (K.stupidTrunc e).X i' ‚âÖ K.X i' :=
  (K.restriction e).extendXIso e hi' ‚â™‚â´ eqToIso (by subst hi'; rfl)

lemma isZero_stupidTrunc_X (i' : Œπ') (hi' : ‚àÄ i, e.f i ‚â† i') :
    IsZero ((K.stupidTrunc e).X i') :=
  isZero_extend_X _ _ _ hi'

instance {Œπ'' : Type*} {c'' : ComplexShape Œπ''} (e' : c''.Embedding c')
    [K.IsStrictlySupported e'] :
    IsStrictlySupported (K.stupidTrunc e) e' where
  isZero i' hi' := by
    by_cases hi'' : ‚àÉ i, e.f i = i'
    ¬∑ obtain ‚ü®i, hi‚ü© := hi''
      exact (K.isZero_X_of_isStrictlySupported e' i' hi').of_iso (K.stupidTruncXIso e hi)
    ¬∑ apply isZero_stupidTrunc_X
      simpa using hi''

@[target]
lemma isZero_stupidTrunc_iff :
    IsZero (K.stupidTrunc e) ‚Üî K.IsStrictlySupportedOutside e := by sorry

variable {K L M}

/-- The morphism `K.stupidTrunc e ‚ü∂ L.stupidTrunc e` induced by a morphism `K ‚ü∂ L`. -/
noncomputable def stupidTruncMap : K.stupidTrunc e ‚ü∂ L.stupidTrunc e :=
  extendMap (restrictionMap œÜ e) e

variable (K) in
@[target, simp]
lemma stupidTruncMap_id : stupidTruncMap (ùüô K) e = ùüô _ := by sorry

@[target, simp, reassoc]
lemma stupidTruncMap_comp :
    stupidTruncMap (œÜ ‚â´ œÜ') e = stupidTruncMap œÜ e ‚â´ stupidTruncMap œÜ' e := by sorry

@[target, reassoc (attr := by sorry

end HomologicalComplex

namespace ComplexShape.Embedding

variable (e : Embedding c c') (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]

/-- The stupid truncation functor `HomologicalComplex C c' ‚•§ HomologicalComplex C c'`
given by an embedding `e : Embedding c c'` of complex shapes. -/
@[simps]
noncomputable def stupidTruncFunctor [e.IsRelIff] :
    HomologicalComplex C c' ‚•§ HomologicalComplex C c' where
  obj K := K.stupidTrunc e
  map œÜ := HomologicalComplex.stupidTruncMap œÜ e

end ComplexShape.Embedding
